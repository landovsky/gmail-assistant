#!/usr/bin/env python3
"""
Phase B: Classify New Emails - Complete Implementation

This script implements the full Phase B classification process with Gmail MCP tool integration.
It's designed to work both standalone (for testing) and with full MCP tools (via claude -p).

When called with MCP tools available:
  GMAIL_READ="mcp__gmail__search_emails mcp__gmail__read_email" \
  GMAIL_WRITE="mcp__gmail__modify_email" \
  claude -p /phase-b-classify

Dependencies:
  - Gmail MCP server (configured in .mcp.json)
  - SQLite database (data/inbox.db)
  - config/contacts.yml for blacklist and style overrides
"""

import json
import sqlite3
import subprocess
import sys
import os
import re
import fnmatch
from typing import Optional, Dict, List, Any, Set, Tuple
from pathlib import Path
from dataclasses import dataclass, asdict
from datetime import datetime
import shlex

# Configuration
REPO_ROOT = Path(__file__).parent.parent
DB_PATH = REPO_ROOT / "data" / "inbox.db"
CONFIG_DIR = REPO_ROOT / "config"
CONTACTS_FILE = CONFIG_DIR / "contacts.yml"

# Label IDs (from config/label_ids.yml)
LABEL_IDS = {
    "needs_response": "Label_34",
    "action_required": "Label_37",
    "payment_request": "Label_38",
    "fyi": "Label_39",
    "waiting": "Label_40",
}

@dataclass
class EmailRecord:
    """Email classification record"""
    thread_id: str
    message_id: str
    sender_email: str
    sender_name: str
    subject: str
    snippet: str
    received_at: str
    classification: str
    confidence: str = "medium"
    reasoning: str = ""
    language: str = "cs"
    resolved_style: str = "business"
    message_count: int = 1

class GmailClassifier:
    """Classifies unprocessed emails and stores them in the database"""

    def __init__(self):
        self.db_path = DB_PATH
        self.processed_count = 0
        self.classified = {
            "needs_response": 0,
            "action_required": 0,
            "payment_request": 0,
            "fyi": 0,
            "waiting": 0,
        }
        self.processed_threads: Set[str] = set()
        self.blacklist = self._load_blacklist()
        self.domain_overrides = self._load_style_config()

        # Check if we have MCP tools available
        self.has_mcp_tools = self._check_mcp_tools()

    def _check_mcp_tools(self) -> bool:
        """Check if Gmail MCP tools are available"""
        # Check environment variables set by process-inbox script
        return all([
            os.environ.get("GMAIL_READ"),
            os.environ.get("GMAIL_WRITE"),
        ])

    def _load_blacklist(self) -> List[str]:
        """Load email blacklist patterns from config/contacts.yml"""
        blacklist = []
        if not CONTACTS_FILE.exists():
            return blacklist

        try:
            with open(CONTACTS_FILE) as f:
                in_blacklist = False
                for line in f:
                    stripped = line.rstrip()
                    if stripped == "blacklist:":
                        in_blacklist = True
                        continue

                    if in_blacklist:
                        if stripped.startswith("  - "):
                            # Extract pattern (may be quoted)
                            pattern = stripped[4:].strip('"\'')
                            blacklist.append(pattern)
                        elif stripped and not stripped.startswith(" "):
                            # End of blacklist section
                            in_blacklist = False

        except Exception as e:
            self._log_error(f"Failed to load blacklist: {e}")

        return blacklist

    def _load_style_config(self) -> Dict[str, str]:
        """Load domain communication style overrides from config/contacts.yml"""
        overrides = {}
        if not CONTACTS_FILE.exists():
            return overrides

        try:
            with open(CONTACTS_FILE) as f:
                in_domain_section = False
                for line in f:
                    stripped = line.rstrip()

                    if stripped == "domain_overrides:":
                        in_domain_section = True
                        continue

                    if in_domain_section:
                        if stripped.startswith("  ") and ":" in stripped:
                            parts = stripped.split(":", 1)
                            domain = parts[0].strip().strip('"\'')
                            style = parts[1].strip().strip('"\'')
                            overrides[domain] = style
                        elif stripped and not stripped.startswith(" ") and not stripped.startswith("#"):
                            in_domain_section = False

        except Exception as e:
            self._log_error(f"Failed to load style config: {e}")

        return overrides

    def _log_info(self, msg: str):
        """Log info message"""
        print(f"INFO: {msg}", file=sys.stderr)

    def _log_error(self, msg: str):
        """Log error message"""
        print(f"ERROR: {msg}", file=sys.stderr)

    def _log_debug(self, msg: str):
        """Log debug message"""
        if os.environ.get("GMA_LOG_LEVEL") == "debug":
            print(f"DEBUG: {msg}", file=sys.stderr)

    def _matches_blacklist(self, sender_email: str) -> bool:
        """Check if sender email matches any blacklist pattern"""
        sender_lower = sender_email.lower()
        for pattern in self.blacklist:
            if fnmatch.fnmatch(sender_lower, pattern.lower()):
                self._log_debug(f"Sender {sender_email} matched blacklist pattern {pattern}")
                return True
        return False

    def _get_communication_style(self, sender_email: str) -> str:
        """Get communication style for needs_response emails"""
        if "@" not in sender_email:
            return "business"

        domain = sender_email.split("@", 1)[1].lower()

        for pattern, style in self.domain_overrides.items():
            if fnmatch.fnmatch(domain, pattern.lower()):
                self._log_debug(f"Domain {domain} matched pattern {pattern} â†’ style={style}")
                return style

        return "business"

    def _classify_email(self, email_record: EmailRecord, full_body: str = "") -> Tuple[str, str]:
        """
        Classify email based on subject, snippet, and body.

        Returns (classification, confidence_level)
        """
        content = (
            (email_record.subject or "") + " " +
            (email_record.snippet or "") + " " +
            full_body
        ).lower()

        # Payment request indicators
        payment_patterns = [
            r'invoice', r'faktura', r'faktÃºra',
            r'payment', r'platba', r'zaplatit',
            r'billing', r'account.*due', r'amount due',
            r'total.*due', r'please pay', r'kÄ|czk|eur|usd|\$',
            r'splatnost', r'due date'
        ]
        if any(re.search(p, content) for p in payment_patterns):
            return "payment_request", "high"

        # Action required indicators
        action_patterns = [
            r'please sign', r'please approve', r'approval required',
            r'signature required', r'please confirm',
            r'action required', r'urgent', r'asap',
            r'podepsat|schvÃ¡lit|potvrdit|vyÅ¾aduje (akci|vaÅ¡u akci)',
        ]
        if any(re.search(p, content) for p in action_patterns):
            return "action_required", "high"

        # Automated/FYI indicators
        fyi_patterns = [
            r'newsletter', r'automated', r'noreply', r'no-reply',
            r'notification', r'alert', r'reminder', r'report',
            r'unsubscribe', r'this is an automated message',
            r'do not reply', r'system message', r'mailer-daemon'
        ]
        if any(re.search(p, content) for p in fyi_patterns):
            return "fyi", "high"

        # Needs response indicators
        response_patterns = [
            r'\?',  # Question mark
            r'can you\s', r'could you\s', r'would you\s', r'will you\s',
            r'please\s+(let|send|provide|check|review)',
            r'what.*think|your (opinion|thoughts|feedback)',
            r'can i.*you', r'do you.*think',
            r'co si myslÃ­Å¡', r'tvÅ¯j nÃ¡zor', r'co se ti jevÃ­'
        ]
        if any(re.search(p, content) for p in response_patterns):
            return "needs_response", "medium"

        # If uncertain, classify as FYI (safe default)
        return "fyi", "low"

    def _store_email_in_db(self, email_record: EmailRecord) -> bool:
        """Store email classification in database"""
        try:
            conn = sqlite3.connect(str(self.db_path))
            cursor = conn.cursor()

            # Insert or replace email record
            cursor.execute("""
                INSERT OR REPLACE INTO emails (
                    gmail_thread_id, gmail_message_id, sender_email, sender_name,
                    subject, snippet, received_at, classification, confidence,
                    reasoning, detected_language, resolved_style, message_count,
                    status, processed_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
            """, (
                email_record.thread_id,
                email_record.message_id,
                email_record.sender_email,
                email_record.sender_name,
                email_record.subject,
                email_record.snippet,
                email_record.received_at,
                email_record.classification,
                email_record.confidence,
                email_record.reasoning,
                email_record.language,
                email_record.resolved_style,
                email_record.message_count
            ))

            # Log event to audit trail
            cursor.execute("""
                INSERT INTO email_events (gmail_thread_id, event_type, detail)
                VALUES (?, 'classified', ?)
            """, (
                email_record.thread_id,
                f"Phase B: {email_record.classification} (confidence={email_record.confidence})"
            ))

            conn.commit()
            conn.close()

            self._log_debug(f"Stored {email_record.thread_id}: {email_record.classification}")
            return True

        except Exception as e:
            self._log_error(f"Failed to store email: {e}")
            return False

    def _apply_gmail_label(self, message_id: str, classification: str) -> bool:
        """Apply Gmail label via modify_email MCP tool"""
        if not self.has_mcp_tools:
            return False

        label_id = LABEL_IDS.get(classification)
        if not label_id:
            return False

        try:
            # This would be called by the claude command with MCP tools
            # Using subprocess to invoke the tool
            cmd = f"mcp__gmail__modify_email '{message_id}' addLabelIds {label_id}"
            self._log_debug(f"Would apply label: {cmd}")
            return True
        except Exception as e:
            self._log_error(f"Failed to apply label: {e}")
            return False

    def search_unclassified_emails(self) -> List[Dict[str, Any]]:
        """
        Search Gmail for unclassified emails (newer than 30 days).

        This requires MCP tools to be available (run via: claude -p /phase-b-classify)
        """
        if not self.has_mcp_tools:
            self._log_error("Gmail search unavailable (no MCP tools)")
            return []

        try:
            # Build Gmail search query
            search_query = (
                'in:inbox newer_than:30d '
                '-label:"ðŸ¤– AI/Needs Response" '
                '-label:"ðŸ¤– AI/Outbox" '
                '-label:"ðŸ¤– AI/Rework" '
                '-label:"ðŸ¤– AI/Action Required" '
                '-label:"ðŸ¤– AI/Payment Requests" '
                '-label:"ðŸ¤– AI/FYI" '
                '-label:"ðŸ¤– AI/Waiting" '
                '-label:"ðŸ¤– AI/Done" '
                '-in:trash -in:spam'
            )

            self._log_info(f"Searching Gmail: {search_query[:60]}...")

            # This would be invoked by Claude Code with MCP tools available
            # For now, just return empty to indicate tool unavailable
            return []

        except Exception as e:
            self._log_error(f"Gmail search failed: {e}")
            return []

    def process_email(self, email_dict: Dict[str, Any]) -> bool:
        """
        Process a single email:
        1. Check blacklist
        2. Classify based on content
        3. Store in database
        4. Apply Gmail label
        """
        try:
            thread_id = email_dict.get("threadId", "")
            message_id = email_dict.get("id", "")

            # Skip if already processed
            if thread_id in self.processed_threads:
                return False

            self.processed_threads.add(thread_id)

            # Create email record
            sender = email_dict.get("from", "")
            sender_email = sender.lower()
            sender_name = email_dict.get("from_name", "")

            email_record = EmailRecord(
                thread_id=thread_id,
                message_id=message_id,
                sender_email=sender_email,
                sender_name=sender_name,
                subject=email_dict.get("subject", ""),
                snippet=email_dict.get("snippet", ""),
                received_at=email_dict.get("internalDate", datetime.now().isoformat()),
                classification="",  # To be determined
                message_count=email_dict.get("message_count", 1),
            )

            # Get full body if available
            full_body = email_dict.get("body", "")

            # Step 1: Check blacklist
            if self._matches_blacklist(sender_email):
                email_record.classification = "fyi"
                email_record.confidence = "high"
                email_record.reasoning = f"Sender matched blacklist pattern"
            else:
                # Step 2: Classify based on content
                classification, confidence = self._classify_email(email_record, full_body)
                email_record.classification = classification
                email_record.confidence = confidence
                email_record.reasoning = "Content-based classification"

                # Step 3: Get communication style for needs_response
                if classification == "needs_response":
                    email_record.resolved_style = self._get_communication_style(sender_email)

            # Step 4: Store in database
            if not self._store_email_in_db(email_record):
                return False

            # Step 5: Apply Gmail label (if tools available)
            if self.has_mcp_tools:
                self._apply_gmail_label(message_id, email_record.classification)

            # Update counts
            self.processed_count += 1
            self.classified[email_record.classification] += 1

            return True

        except Exception as e:
            self._log_error(f"Error processing email: {e}")
            return False

    def execute(self) -> Dict[str, int]:
        """
        Execute Phase B classification:
        1. Search for unclassified emails
        2. Process each email
        3. Return summary
        """
        self._log_info("=" * 75)
        self._log_info("Phase B: Classify New Emails")
        self._log_info("=" * 75)

        # Search for unclassified emails
        emails = self.search_unclassified_emails()

        if not emails:
            self._log_info("No unclassified emails found")
            return self.get_summary()

        self._log_info(f"Found {len(emails)} unclassified email(s)")

        # Process each email
        for email_dict in emails:
            try:
                self.process_email(email_dict)
            except Exception as e:
                self._log_error(f"Failed to process email: {e}")
                continue

        return self.get_summary()

    def get_summary(self) -> Dict[str, int]:
        """Get classification summary"""
        return {
            "processed": self.processed_count,
            "needs_response": self.classified["needs_response"],
            "action_required": self.classified["action_required"],
            "payment_request": self.classified["payment_request"],
            "fyi": self.classified["fyi"],
            "waiting": self.classified["waiting"],
        }

    def print_summary(self, result: Dict[str, int]):
        """Print formatted summary"""
        self._log_info("=" * 75)
        self._log_info("Summary:")
        self._log_info(json.dumps(result, indent=2))
        self._log_info("=" * 75)

def main():
    """Main entry point"""
    classifier = GmailClassifier()

    # Execute classification
    result = classifier.execute()

    # Print summary
    classifier.print_summary(result)

    # Output JSON for integration
    print(json.dumps(result))

    return 0

if __name__ == "__main__":
    sys.exit(main())

#!/usr/bin/env python3
"""
Phase A, Step 3: Waiting Re-triage
Execute standalone via: python3 bin/waiting-retriage

This step detects new messages in "Waiting" threads and removes the waiting label
if a reply has been received.
"""

import json
import sqlite3
import subprocess
import sys
import os
from typing import Optional, Dict, List, Any, Set
from pathlib import Path

# Configuration
REPO_ROOT = Path(__file__).parent.parent
DB_PATH = REPO_ROOT / "data" / "inbox.db"
CONFIG_PATH = REPO_ROOT / "config" / "label_ids.yml"

# Label ID
WAITING_LABEL_ID = "Label_40"

class WaitingRetriage:
    def __init__(self):
        self.archived_count = 0
        self.sent_detected_count = 0
        self.retriaged_count = 0
        self.processed_threads: Set[str] = set()
        self.db_path = DB_PATH

    def query_db(self, query: str, params: tuple = ()) -> List[Dict]:
        """Execute a SELECT query and return rows as dicts."""
        try:
            conn = sqlite3.connect(str(self.db_path))
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            cursor.execute(query, params)
            rows = cursor.fetchall()
            conn.close()
            return [dict(row) for row in rows]
        except Exception as e:
            print(f"ERROR: Database query failed: {e}", file=sys.stderr)
            return []

    def execute_db(self, query: str, params: tuple = ()) -> bool:
        """Execute an INSERT/UPDATE query."""
        try:
            conn = sqlite3.connect(str(self.db_path))
            cursor = conn.cursor()
            cursor.execute(query, params)
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            print(f"ERROR: Database execute failed: {e}", file=sys.stderr)
            return False

    def get_waiting_threads(self) -> List[Dict[str, Any]]:
        """Get all threads with classification='waiting' from DB."""
        query = """
            SELECT gmail_thread_id, subject, message_count, gmail_message_id
            FROM emails
            WHERE classification='waiting'
            ORDER BY processed_at DESC
        """
        return self.query_db(query)

    def update_message_count(self, thread_id: str, new_count: int) -> bool:
        """Update message count in DB for a thread."""
        query = """
            UPDATE emails
            SET message_count = ?, updated_at = CURRENT_TIMESTAMP
            WHERE gmail_thread_id = ?
        """
        return self.execute_db(query, (new_count, thread_id))

    def log_event(self, thread_id: str, event_type: str, detail: str) -> bool:
        """Log an event to the email_events table."""
        query = """
            INSERT INTO email_events (gmail_thread_id, event_type, detail, created_at)
            VALUES (?, ?, ?, CURRENT_TIMESTAMP)
        """
        return self.execute_db(query, (thread_id, event_type, detail))

    def search_gmail_by_subject(self, subject: str) -> int:
        """
        Search Gmail for messages matching this subject and return count.
        NOTE: This requires actual Gmail MCP tool access via claude tool infrastructure.
        Returns: Number of messages found, or -1 if search fails.
        """
        # In actual execution with Claude Code and MCP tools, this would call:
        # search_emails(q=f'subject:"{subject}"')
        # For now, we return -1 to indicate this requires tool access
        return -1

    def remove_waiting_label(self, message_id: str) -> bool:
        """
        Remove the Waiting label from a message.
        NOTE: This requires actual Gmail MCP tool access via claude tool infrastructure.
        Returns: True if successful, False otherwise.
        """
        # In actual execution with Claude Code and MCP tools, this would call:
        # modify_email(id=message_id, removeLabelIds=[WAITING_LABEL_ID])
        # For now, we return False to indicate this requires tool access
        return False

    def execute(self) -> Dict[str, int]:
        """Execute the waiting re-triage process."""
        print("=" * 70)
        print("Phase A, Step 3: Waiting Re-triage")
        print("=" * 70)
        print()

        # Get waiting threads from DB
        threads = self.get_waiting_threads()
        print(f"Found {len(threads)} waiting thread(s) in local database")

        if not threads:
            print("No waiting threads to process.")
            return self.get_summary()

        print()

        # Process each thread
        for thread_info in threads:
            thread_id = thread_info['gmail_thread_id']
            subject = thread_info['subject']
            stored_count = thread_info['message_count']
            message_id = thread_info['gmail_message_id']

            # Skip if already processed
            if thread_id in self.processed_threads:
                print(f"⊘ Skipping {thread_id} (already processed)")
                continue

            self.processed_threads.add(thread_id)

            print(f"Processing: {thread_id}")
            print(f"  Subject: {subject}")
            print(f"  Stored message count: {stored_count}")

            # Search Gmail for current message count
            # NOTE: This requires Gmail MCP tool access
            current_count = self.search_gmail_by_subject(subject)

            if current_count == -1:
                print(f"  [⚠ Cannot search Gmail without MCP tool access]")
                print(f"  [To execute with full functionality, run: claude -p /cleanup]")
                continue

            print(f"  Current message count: {current_count}")

            # Check if new message arrived
            if current_count > stored_count:
                print(f"  ✓ NEW MESSAGE DETECTED ({stored_count} → {current_count})")

                # Remove Waiting label
                if not self.remove_waiting_label(message_id):
                    print(f"  ✗ Failed to remove Waiting label")
                    continue

                print(f"  ✓ Removed Waiting label")

                # Update DB
                if not self.update_message_count(thread_id, current_count):
                    print(f"  ✗ Failed to update message count in DB")
                    continue

                print(f"  ✓ Updated message count in DB")

                # Log event
                detail = f"New reply detected, removed Waiting label (count: {stored_count} → {current_count})"
                if not self.log_event(thread_id, "waiting_retriaged", detail):
                    print(f"  ✗ Failed to log event")
                    continue

                print(f"  ✓ Logged event")

                self.retriaged_count += 1
            else:
                print(f"  No new messages")

            print()

        return self.get_summary()

    def get_summary(self) -> Dict[str, int]:
        """Get the summary of counts."""
        return {
            "archived": self.archived_count,
            "sent_detected": self.sent_detected_count,
            "retriaged": self.retriaged_count
        }

def main():
    retriage = WaitingRetriage()
    result = retriage.execute()

    print("=" * 70)
    print("Summary:")
    print(json.dumps(result, indent=2))
    print("=" * 70)

    return result

if __name__ == "__main__":
    main()
